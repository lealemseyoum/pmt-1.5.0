#! c:\perl\bin\perl.exe -w
#
# The purpose of this program is to create a .h include file from an XML document.
# This allows an application to compile into itself a lengthy array of bytes from an XML
# source file.
#
# The reasons for needing this program are two fold:
# 1.) Since C++ compilers have a limit to the number of characters that can be used for
# C string constants, this program gets around that limit by breaking up long strings
# into smaller chunks - an array of char pointers. (You can inspect the resultant .h
# file for details.)
# 2.) This program allows a source XML file, such as a schema or PMT translation table,
# to be kept seperate from a corresponding .h file. The source XML file can be considered
# the official latest correct version of a desired XML file, and can thus be checked for
# well formedness or validity in tools such as XML Spy. Keeping things in sync can then
# be handled by this program, generating a corresponding .h file whenever the official
# XML source file is modified.
#
# The resultant .h file assigns the XML stream of bytes to a global character pointer
# array, which has its name automatically generated. See the .h file for the variable
# name to use in your code.
#
# For typical use in PMT, you will call the "convertMemoryVariableToString"
# and "loadMemory" methods to use the global variable from the resultant .h file.
# See the PmtInterpreterTest.cpp and AccessorTest.cpp files for example code.
#
# This program, with no command-line arguments, takes the "PmtDefaultDefinitions.xsd"
# file as input and generates the "PmtDefaultDefinitions.h" file as output, into
# the appropriate directory for building PMT.
#
# The default input and output file arguments may be overidden via the command-line
# options "-i" and "-o".  You would specify your XML source file with the "-i"
# option, and the resultant .h file with the "-o" option.
#
# When command-line arguments are specified, ensure the resultant .h file is placed into
# the appropriate directory for building your application. Or, simply provide the
# correct path within which to generate your .h file.


use strict;
use Getopt::Std;

my ($debug, $infile, $outfile, $reg, $rv, $lw, $scount);
$scount = 0;


sub Main
{
    my ($rs, $cl, $cc, $tc, $commandLineArgs);

    $lw = 950;
    $infile = "../DefaultDefinitions/PmtDefaultDefinitions.xsd";
    $outfile = "../src/PmtInterpreter/PmtDefaultDefinitions.h";

    getopts('di:o:');

    # Do this operation twice to eliminate Perl's warning
    # about only using $Getopt::Std::opt_d once.
    $debug = $Getopt::Std::opt_d;
    $debug = $Getopt::Std::opt_d;

    $commandLineArgs = 0;

    # Override input and output arguments, if available.
    if ($Getopt::Std::opt_i)
    {
        $infile = $Getopt::Std::opt_i;
        $commandLineArgs = 1;
    }

    if ($Getopt::Std::opt_o)
    {
        $outfile = $Getopt::Std::opt_o;
    }

    print "reading from $infile\n" if ($debug);
    open( INFILE, $infile) || die("\nError: Cannot open $infile for reading!\n");

    print "writing to $outfile\n" if ($debug);
    open( OUTFILE, ">$outfile") || die("\nError: Cannot open $outfile for writing!\n");

    print OUTFILE "//--------------------------------------------//\n";
    print OUTFILE "// This file automatically generated by Perl. //\n";
    print OUTFILE "//               DO NOT EDIT!                 //\n";
    print OUTFILE "//--------------------------------------------//\n";

    if (not $commandLineArgs)
    {
        print OUTFILE "\n#ifndef PMT_DEFAULT_DEFINITIONS_H\n#define PMT_DEFAULT_DEFINITIONS_H\n";
        print OUTFILE "const char * const PmtLogicalDefinitionInterpreter::msPmtDefaultDefinitionsArray[] = {\n";
    }
    else
    {
        $Getopt::Std::opt_o || die ("\nError: Must specify an output file (with the -o option) when an input\nfile is specified!\n");

        my ($outfileNoExtension);
        $outfileNoExtension = $outfile;

        substr($outfile, -2) eq ".h" || die("\nError: Output file must have '.h' extension!\n");

        my ($len);
        $len = length($outfile);
        $outfileNoExtension = substr($outfile, 0, $len - 2);

        # Remove the file path, leaving just the file name itself.
	    if ($outfileNoExtension =~ /\\/ || $outfileNoExtension =~ /\// )
	    {
	        my @fields;
	        my $numFields;

	        # split returns number of substrings in scalar context
	        # split returns tokenized arguments into list in list context
	        $numFields = @fields = split /\\/, $outfileNoExtension;

			if( $numFields == 1 )
			{
				$numFields = @fields = split /\//, $outfileNoExtension;
			}

            $outfileNoExtension = $fields[$numFields - 1];
	    }

        print OUTFILE "\n#ifndef PMT_" . $outfileNoExtension . "_H\n#define PMT_" . $outfileNoExtension . "_H\n";
        print OUTFILE "const char * const " . $outfileNoExtension . "[] = {\n";
    }

    $rs = $reg;

    $cc = $tc = 0;

    while (<INFILE>)
    {
        $tc += length;
        $cl = $_;
        chop;
        if ($_)
        {
            s/"/\\"/g;
            print OUTFILE '"' if ($cc == 0);
            print OUTFILE $_, "\\\n";
            $cc += length($cl);
            if ($cc >= $lw)
            {
                print OUTFILE '",', "\n";
                $cc = 0;
                $scount++;
            }
        }
    }

    if ($cc > 0)
    {
        print OUTFILE '",', "\n";
    }

    print OUTFILE "NULL\n};\n";
    print OUTFILE "\n#endif";

    return ($tc);
}


$rv = Main();
print "done, rv = $rv, $scount segment(s)\n" if $debug;


